
##############################################################
# macros: should be first

# CLAMD = yes
# SPAMASSASSIN = yes

##############################################################
# global section


# noneed to set it, exim will get from hostname
# primary_hostname = myhost.name

smtp_active_hostname = ${lookup dnsdb{>: defer_never,ptr=$interface_address}{${listextract{1}{$value}}}{$primary_hostname}}
smtp_banner = $smtp_active_hostname

domainlist local_domains = dsearch;/etc/exim/domains/
domainlist relay_to_domains = dsearch;/etc/exim/domains/
# hostlist relay_from_hosts =<; 127.0.0.1 ; ::1
hostlist relay_from_hosts = 127.0.0.1
hostlist allowedhosts = net-iplsearch;/etc/exim/allowed-hosts.conf
hostlist spammers = net-iplsearch;/etc/exim/spam-blocks.conf

no_allow_domain_literals
no_local_from_check
untrusted_set_sender = *


acl_not_smtp = acl_not_smtp
acl_smtp_connect = acl_check_connect
acl_smtp_mail = acl_check_mail
acl_smtp_rcpt = acl_check_rcpt
acl_smtp_data = acl_check_data
acl_smtp_mime = acl_check_mime
# .ifdef _HAVE_PRDR
# acl_smtp_data_prdr =    acl_check_prdr
# .endif


.ifdef SPAMASSASSIN
spamd_address = 127.0.0.1 783
.endif

.ifdef CLAMD
# even with permissive selinux, might not be available, reboot
av_scanner = clamd:/run/clamav/clamd.sock
.endif

tls_advertise_hosts = *
# tls_in_sni expands to mail.domain.tld
# validate cert with: 
# openssl s_client -connect mail.example.com:465 
# check certs data:
# openssl s_client -showcerts -connect mail.example.com:465

# tls_privatekey = ${if exists{/etc/exim/cert/${tls_in_sni}/mail.key}{/etc/exim/cert/${tls_in_sni}/mail.key}{/usr/local/qweec/cert/host.key}}
# tls_certificate = ${if exists{/etc/exim/cert/${tls_in_sni}/mail.pem}{/etc/exim/cert/${tls_in_sni}/mail.pem}{/usr/local/qweec/cert/host.pem}}

tls_privatekey =  ${if match {$tls_in_sni}{^mail\.}{${if exists{/etc/exim/domains/${lookup{${substr{5}{${tls_in_sni}}}}dsearch{/etc/exim/domains/}}/mail.key}{/etc/exim/domains/${lookup{${substr{5}{${tls_in_sni}}}}dsearch{/etc/exim/domains/}}/mail.key}{/usr/local/qweec/cert/host.key}}}{/usr/local/qweec/cert/host.key}}
tls_certificate = ${if match {$tls_in_sni}{^mail\.}{${if exists{/etc/exim/domains/${lookup{${substr{5}{${tls_in_sni}}}}dsearch{/etc/exim/domains/}}/mail.pem}{/etc/exim/domains/${lookup{${substr{5}{${tls_in_sni}}}}dsearch{/etc/exim/domains/}}/mail.pem}{/usr/local/qweec/cert/host.pem}}}{/usr/local/qweec/cert/host.pem}}


# do not offer resumption to (most) MUAs, who we don't want to reuse tickets.  
# once the TLS extension for vended ticket numbers comes though, 
# re-examine since resumption on a single-use ticket is still a benefit.
# .ifdef _HAVE_TLS_RESUME
# tls_resumption_hosts = ${if inlist {$received_port}{587:465} {:}{*}}
# .endif

# local_interfaces = <; ::0 ; 0.0.0.0
daemon_smtp_ports = 25 : 465 : 587
tls_on_connect_ports = 465


# error: SMTP protocol synchronization error (next input sent too soon: pipelining was advertised): rejected ""
smtp_enforce_sync = false
# not supported on rhel, exim should be compiled with i18n support
# error: SMTPUTF8 is required, but was not offered by host
# smtputf8_advertise_hosts =

disable_ipv6 = true


never_users = root
# does a rdns lookup on all incoming connections to get a host name
host_lookup = *

openssl_options=+no_sslv2 +no_sslv3 +cipher_server_preference

# should be placed above auth_advertise_hosts
tls_require_ciphers = ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:AES256-GCM-SHA384:AES256-SHA:DHE-RSA-AES256-GCM-SHA384:!DSS


# AUTH LOGIN or AUTH PLAIN can be used on ports 25 and 587 to authenticate against the mail server and the password will be sent in clear text over the internet.
# to prevent sending password in the clear, advertise AUTH mechanisms only for localhost and for connections over tls 
auth_advertise_hosts = localhost : ${if eq{$tls_in_cipher}{}{}{*}}

# avoid ident callbacks for all incoming smtp calls
rfc1413_hosts = *
rfc1413_query_timeout = 4s

# prdp - an efficiency feature. 
# We advertise the feature; clients may request to use it. 
# for multi-recipient mails we then can reject or accept per-user after the message is received.
# supports recipient-dependent content filtering; 
# without it you have to temp-reject any recipients after the first that have incompatible filtering, and do the filtering in the data ACL.
# even with this enabled, you must support the old style for peers not flagging support for PRDR (visible via $prdr_requested).
# .ifdef _HAVE_PRDR
# prdr_enable = true
# .endif

# uncomment only during debugging, do not uncomment on a high-volume server
# log_selector = +smtp_protocol_error +smtp_syntax_error +tls_certificate_verified

ignore_bounce_errors_after = 2d
timeout_frozen_after = 5d
# noneed, can improve performance for large queues, but overcomplicates manual manipulation of queued messages
# split_spool_directory = true

keep_environment =
add_environment = <; PATH=/usr/bin:/bin


######################################################################
# acl: specifies access control lists for incoming SMTP mail , order is important
begin acl

acl_not_smtp:
  # deny    condition = ${if >{$sender_rate}{300}{yes}{no}}
  deny    condition     = ${if def:$authenticated_id}
          ratelimit     = 300 / 1h / $authenticated_id
          message       = too many emails sent from authenticated user $authenticated_id - rate limiting applied

  condition             = ${if and{{def:$sender_ident}{!def:$authenticated_id}}}
          ratelimit     = 100 / 1h / strict / $sender_ident
          message       = too many emails sent from user $sender_ident - rate limiting applied

  accept


acl_check_connect:
  accept  hosts         = +allowedhosts

  drop    message       = Your host in blocklist on this server.
          log_message   = Host in blocklist
          hosts         = +spammers

  accept


acl_check_mail:
  deny    condition     = ${if eq{$sender_helo_name}{}}
          message       = HELO required before MAIL

  drop    message       = Helo name contains a ip address (HELO was $sender_helo_name) and is not valid
          condition     = ${if match{$sender_helo_name}{\N((\d{1,3}[.-]\d{1,3}[.-]\d{1,3}[.-]\d{1,3})|([0-9a-f]{8})|([0-9A-F]{8}))\N}{yes}{no}}
          condition     = ${if match {${lookup dnsdb{>: defer_never,ptr=$sender_host_address}}\}{$sender_helo_name}{no}{yes}}
          delay         = 45s

  drop    condition     = ${if isip{$sender_helo_name}}
          message       = Access denied - Invalid HELO name (See RFC2821 4.1.3)

  drop    condition     = ${if eq{[$received_ip_address]}{$sender_helo_name}}
          message       = $received_ip_address is _my_ address

  accept


acl_check_rcpt:
  accept  hosts         = :

  deny    message       = Restricted characters in address
          domains       = +local_domains
          local_parts   = ^[.] : ^.*[@%!/|]

  deny    message       = Restricted characters in address
          domains       = !+local_domains
          local_parts   = ^[./|] : ^.*[@%!] : ^.*/\\.\\./

  require verify        = sender

  # reject all RCPT commands after too many bad recipients
  # this is partly a defense against spam abuse and partly attacker abuse.
  # real senders should manage, by the time they get to a specified number of RCPT directives, to have had at least half of them be real addresses.
  # this is a lightweight check and can protect you against repeated invocations of more heavy-weight checks which would come after it.
  deny    condition     = ${if and {\
                        {>{$rcpt_count}{20}}\
                        {<{$recipients_count}{${eval:$rcpt_count/2}}} }}
          message       = Rejected for too many bad recipients
          logwrite      = REJECT [$sender_host_address]: bad recipient count high [${eval:$rcpt_count-$recipients_count}]

  accept  hosts         = +relay_from_hosts
          control       = submission

  accept  authenticated = *
          control       = submission/domain=

  deny    message       = Rejected because $sender_host_address is in a block list at $dnslist_domain\n$dnslist_text
          hosts         = !+allowedhosts
          dnslists      = ${readfile {/etc/exim/dnsbl.conf}{:}}

  require message       = relay not permitted
          domains       = +local_domains : +relay_to_domains

  deny    message       = smtp auth requried
         sender_domains = +local_domains
         !authenticated = *

  require verify        = recipient

.ifdef CLAMD
  warn    set acl_m0    = no

  warn    condition     = ${if exists {/etc/exim/domains/$domain/antivirus}{yes}{no}}
          set acl_m0    = yes
.endif

.ifdef SPAMASSASSIN
  warn    set acl_m1    = no

  warn    condition     = ${if exists {/etc/exim/domains/$domain/antispam}{yes}{no}}
          set acl_m1    = yes
.endif

  accept


# .ifdef _HAVE_PRDR
# acl_check_prdr:
#   warn  set acl_m_did_prdr = y

#   #############################################################################
#   # do lookup on filtering, with $local_part@$domain, deny on filter match
#   #
#   # deny      set acl_m_content_filter = ${lookup PER_RCPT_CONTENT_FILTER}
#   #           condition    = ...
#   #############################################################################

#   accept
# .endif



acl_check_data:

  # deny if the message contains an overlong line. Per the standards # we should never receive one such via SMTP.
  deny    condition     = ${if > {$max_received_linelength}{998}}
          message       = maximum allowed line length is 998 octets, got $max_received_linelength


.ifdef CLAMD
  deny   message        = Message contains a virus ($malware_name) and has been rejected
         malware        = *
         condition      = ${if eq{$acl_m0}{yes}{yes}{no}}
.endif

.ifdef SPAMASSASSIN
  warn   !authenticated = *
         hosts          = !+relay_from_hosts
         condition      = ${if < {$message_size}{100K}}
         condition      = ${if eq{$acl_m1}{yes}{yes}{no}}
         spam           = spamd:true/defer_ok
         add_header     = X-Spam-Score: $spam_score_int
         add_header     = X-Spam-Bar: $spam_bar
         add_header     = X-Spam-Report: $spam_report
         set acl_m2     = $spam_score_int

  warn   condition      = ${if !eq{$acl_m2}{} {yes}{no}}
         # spamscore = 50
         condition      = ${if >{$acl_m2}{50} {yes}{no}}
         add_header     = X-Spam-Status: Yes
         message        = SpamAssassin detected spam (from $sender_address to $recipients).
.endif

  accept


acl_check_mime:
  deny   message        = Blacklisted file extension detected
         condition      = ${if match {${lc:$mime_filename}}{\N(\.ade|\.adp|\.bat|\.chm|\.cmd|\.com|\.cpl|\.exe|\.hta|\.ins|\.isp|\.jse|\.lib|\.lnk|\.mde|\.msc|\.msp|\.mst|\.pif|\.scr|\.sct|\.shb|\.sys|\.vb|\.vbe|\.vbs|\.vxd|\.wsc|\.wsf|\.wsh)$\N}{1}{0}}

  accept



######################################################################
# authenticators
begin authenticators

dovecot_plain:
  driver = dovecot
  public_name = PLAIN
  server_socket = /run/dovecot/auth-client
  server_set_id = $auth1

dovecot_login:
  driver = dovecot
  public_name = LOGIN
  server_socket = /run/dovecot/auth-client
  server_set_id = $auth1



######################################################################
# routers: specifies how addresses are handled, order is important
begin routers

.ifdef ROUTER_SMARTHOST

smarthost:
  driver = manualroute
  domains = ! +local_domains
  transport = smarthost_smtp
  route_data = ROUTER_SMARTHOST
  ignore_target_hosts = <; 0.0.0.0 ; 127.0.0.0/8 ; ::1
  no_more

.else


dnslookup:
  driver = dnslookup
  domains = !+local_domains
  transport = remote_smtp
  # mx can point to hostnames with ips 0.0.0.0 or in 127.0.0.0/8 range. ignoring these ips fails to route the email address, so it bounces. 
  # otherwise, exim would log a routing problem, and continue to try to deliver the message periodically until the address timed out.
  # ignore_target_hosts = 0.0.0.0 : 127.0.0.0/8
  # todo: ipv6
  # ignore_target_hosts = <; 0.0.0.0 ; 127.0.0.0/8 ; ::1
  no_more

.endif


userforward:
  driver = redirect
  check_local_user
  file = $home/.forward
  allow_filter
  no_verify
  no_expn
  check_ancestor
  file_transport = address_file
  pipe_transport = address_pipe
  reply_transport = address_reply

procmail:
  driver = accept
  check_local_user
  require_files = ${local_part}:+${home}/.procmailrc:/usr/bin/procmail
  transport = procmail
  no_verify

user_autoreply:
  driver = accept
  require_files = /etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/autoreply.${local_part}.msg
  condition = ${if exists{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/autoreply.${local_part}.msg}{yes}{no}}
  retry_use_local_part
  transport = userautoreply
  unseen

aliases:
  driver = redirect
  headers_add = X-redirected: yes
  data = ${extract{1}{:}{${lookup{$local_part@$domain}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/aliases}}}}
  require_files = /etc/exim/domains/$domain/aliases
  redirect_router = dnslookup
  pipe_transport = address_pipe
  unseen

localuser_fwd_only:
  driver = accept
  transport = devnull
  condition = ${if exists{/etc/exim/domains/$domain/fwd_only}{${lookup{$local_part}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/fwd_only}{true}{false}}}}

localuser_spam:
  driver = accept
  transport = local_spam_delivery
  condition = ${if eq {${if match{$h_X-Spam-Status:}{\N^Yes\N}{yes}{no}}} {${lookup{$local_part}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/passwd}{yes}{no_such_user}}}}

localuser:
  driver = accept
  transport = local_delivery
  condition = ${lookup{$local_part}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/passwd}{true}{false}}

catchall:
  driver = redirect
  headers_add = X-redirected: yes
  require_files = /etc/exim/domains/$domain/aliases
  data = ${extract{1}{:}{${lookup{*@$domain}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/aliases}}}}
  file_transport = local_delivery
  redirect_router = dnslookup
  condition = ${lookup{$local_part@$domain}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/aliases}{false}{true}}

terminate_alias:
  driver = accept
  transport = devnull
  condition = ${lookup{$local_part@$domain}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/aliases}{true}{false}}



######################################################################
# transports
begin transports

remote_smtp:
  driver = smtp
# .ifdef _HAVE_TLS_RESUME
#   tls_resumption_hosts = *
# .endif
  helo_data = ${lookup dnsdb{>: defer_never,ptr=$sending_ip_address}{${listextract{1}{$value}}}{$primary_hostname}}
  dkim_domain = ${lc:${domain:$h_from:}}
  dkim_selector = mail
  dkim_private_key = ${if exists{/etc/exim/domains/${lookup{${lc:${domain:$h_from:}}}dsearch{/etc/exim/domains/}}/dkimkey.pem}{/etc/exim/domains/${lookup{${lc:${domain:$h_from:}}}dsearch{/etc/exim/domains/}}/dkimkey.pem}{0}}
  dkim_canon = relaxed
  dkim_strict = 0
  interface = ${if def:sender_address_domain{${if exists{/etc/exim/domains/${lookup{$sender_address_domain}dsearch{/etc/exim/domains/}}/ip4}{${lookup{$sender_address_domain}lsearch{/etc/exim/domains/${lookup{$sender_address_domain}dsearch{/etc/exim/domains/}}/ip4}}}{${if exists{/etc/exim/domains/${lookup{$sender_address_domain}dsearch{/etc/exim/domains/}}/ip6}{${lookup{$sender_address_domain}lsearch{/etc/exim/domains/${lookup{$sender_address_domain}dsearch{/etc/exim/domains/}}/ip6}}}{fail}}}}}{fail}}

  # hack to avoid sending on messages with over-long lines
  #message_size_limit = ${if > {$max_received_linelength}{998} {1}{0}}
  # enables an efficiency smtp option
#.ifdef _HAVE_PRDR
#  hosts_try_prdr = *
#.endif


# This transport is used for delivering messages over SMTP using the "message submission" port (RFC4409).
# remote_msa:
#   driver = smtp
#   port = 587
#   hosts_require_auth = *

procmail:
  driver = pipe
  command = "/usr/bin/procmail -d $local_part"
  return_path_add
  delivery_date_add
  envelope_to_add
  user = $local_part
  initgroups
  return_output


# delivers messages to a smarthost, if smarthost router is enabled.  
# starts from the same basis as "remote_smtp" but then turns on various security options, 
# because we assume that if you are told "use smarthost.example.org as the smarthost" then there will be TLS available, 
# with a verifiable certificate for that hostname, using decent TLS.

smarthost_smtp:
  driver = smtp
  message_size_limit = ${if > {$max_received_linelength}{998} {1}{0}}
  multi_domain
  #
.ifdef _HAVE_TLS
  # Comment out any of these which you have to, then file a Support
  # request with your smarthost provider to get things fixed:
  hosts_require_tls = *
  tls_verify_hosts = *
  # As long as tls_verify_hosts is enabled, this this will have no effect,
  # but if you have to comment it out then this will at least log whether
  # you succeed or not:
  tls_try_verify_hosts = *
  #
  # The SNI name should match the name which we'll expect to verify;
  # many mail systems don't use SNI and this doesn't matter, but if it does,
  # we need to send a name which the remote site will recognize.
  # This _should_ be the name which the smarthost operators specified as
  # the hostname for sending your mail to.
  tls_sni = ROUTER_SMARTHOST
  #
.ifdef _HAVE_OPENSSL
  tls_require_ciphers = HIGH:!aNULL:@STRENGTH
.endif
.ifdef _HAVE_GNUTLS
  tls_require_ciphers = SECURE192:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1
.endif
.endif
# .ifdef _HAVE_PRDR
#   hosts_try_prdr = *
# .endif


local_delivery:
  driver = appendfile
  maildir_format
  maildir_use_size_file
  # todo: replace $local_part with $local_part_data as described in chapter 7
  user = ${extract{2}{:}{${lookup{$local_part}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/passwd}}}}
  group = mail
  create_directory
  directory_mode = 770
  mode = 660
  use_lockfile = no
  delivery_date_add
  envelope_to_add
  return_path_add
  directory = "${extract{5}{:}{${lookup{$local_part}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/passwd}}}}/mail/${lookup{$domain}dsearch{/etc/exim/domains/}}/${lookup{$local_part}dsearch{${extract{5}{:}{${lookup{$local_part}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/passwd}}}}/mail/${lookup{$domain}dsearch{/etc/exim/domains/}}}}"
  quota = ${extract{6}{:}{${lookup{$local_part}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/passwd}}}}M
  quota_warn_threshold = 75%

local_spam_delivery:
  driver = appendfile
  maildir_format
  maildir_use_size_file
  user = ${extract{2}{:}{${lookup{$local_part}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/passwd}}}} 
  group = mail
  create_directory
  directory_mode = 770
  mode = 660
  use_lockfile = no
  delivery_date_add
  envelope_to_add
  return_path_add
  directory = "${extract{5}{:}{${lookup{$local_part}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/passwd}}}}/mail/${lookup{$domain}dsearch{/etc/exim/domains/}}/${lookup{$local_part}dsearch{${extract{5}{:}{${lookup{$local_part}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/passwd}}}}/mail/${lookup{$domain}dsearch{/etc/exim/domains/}}}}/.Spam"
  quota = ${extract{6}{:}{${lookup{$local_part}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/passwd}}}}M
  quota_directory = "${extract{5}{:}{${lookup{$local_part}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/passwd}}}}/mail/${lookup{$domain}dsearch{/etc/exim/domains/}}/${lookup{$local_part}dsearch{${extract{5}{:}{${lookup{$local_part}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/passwd}}}}/mail/${lookup{$domain}dsearch{/etc/exim/domains/}}}}"
  quota_warn_threshold = 75%

address_pipe:
  driver = pipe
  return_output

address_file:
  driver = appendfile
  delivery_date_add
  envelope_to_add
  return_path_add

address_reply:
  driver = autoreply

userautoreply:
  driver = autoreply
  file = /etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/autoreply.${extract{1}{:}{${lookup{$local_part}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/accounts}}}}.msg
  from = "${extract{1}{:}{${lookup{$local_part}lsearch{/etc/exim/domains/${lookup{$domain}dsearch{/etc/exim/domains/}}/accounts}}}}@${lookup{$domain}dsearch{/etc/exim/domains/}}"
  headers = Content-Type: text/plain; charset=utf-8;\nContent-Transfer-Encoding: 8bit
  subject = "${if def:h_Subject: {Autoreply: \"${rfc2047:$h_Subject:}\"} {Autoreply Message}}"
  to = "${sender_address}"

devnull:
  driver = appendfile
  file = /dev/null


######################################################################
# retry
begin retry

# Address or Domain    Error       Retries
# -----------------    -----       -------
*                      *           F,2h,15m; G,16h,1h,1.5; F,4d,6h



######################################################################
# rewrite
begin rewrite


######################################################################
# local_scan


